from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding,rsa
from cryptography.hazmat.primitives import hashes
from cryptography.fernet import Fernet

pub_path = "./rsa_keys/server_rsa_public.key"
prv_path = "./rsa_keys/server_rsa_private.key"
pwd = 'abc123'

"""
NAME
DESC
RTRN
PARM
"""
def gen_rsa():
	private_key = rsa.generate_private_key(public_exponent=65537, key_size=2058)
	public_key = private_key.public_key()

	# gen private key
	private_pem = private_key.private_bytes(
		encoding=serialization.Encoding.PEM,
		format=serialization.PrivateFormat.PKCS8,
		encryption_algorithm=serialization.BestAvailableEncryption(pwd.encode())
	)

	# like eve from adam, we generate a public key from the private
	public_pem = public_key.public_bytes(
		encoding=serialization.Encoding.PEM,
		format=serialization.PublicFormat.SubjectPublicKeyInfo
	)
	
	# DECODE FUNCTIONS DO BE A GODSEND <3
	private_pem = private_pem.decode()
	public_pem = public_pem.decode()
	
	# writing to our key storage files
	with open(prv_path, "w") as private_file:
		private_file.write(str(private_pem))
		
	with open(pub_path, "w") as public_file:
		public_file.write(str(public_pem))
		
def load_public_rsa():
	with open(pub_path, "rb") as pub:
		# -- cryptography.hazmat.primitives.serialization.load_pem_private_key(data)
		# deserializes a public key from PEM data
		public_key = serialization.load_pem_public_key (
		# Passing the file's contents as the data field
		pub.read(),
		# Using "default backend"
		backend=default_backend()
		)
		
	return public_key
	
def load_private_rsa():
	with open(prv_path, "rb") as prv:
		private_key = serialization.load_pem_private_key (
			prv.read(),
			pwd.encode()
		)
		
	return private_key

public_key = load_public_rsa()
private_key = load_private_rsa()
encoded_msg = public_key.encrypt (
	b'hello world',
	padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
	algorithm=hashes.SHA256(),
	label=None )
)
decoded_msg = private_key.decrypt (
	encoded_msg,
	padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
	algorithm=hashes.SHA256(),
	label=None )
)

print(decoded_msg.decode())