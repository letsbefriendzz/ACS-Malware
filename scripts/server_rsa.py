from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding,rsa
from cryptography.hazmat.primitives import hashes
from cryptography.fernet import Fernet

pub_path = "../rsa_keys/server_rsa_public.key"
prv_path = "../rsa_keys/server_rsa_private.key"
pwd = 'abc123'

"""
NAME	: ren_rsa()
DESC	:
	This function generates a new pair of RSA public and private keys and writes
	them too our server's rsa_keys/server_rsa_[public][private].key files.
RTRN	: //
PARM	: //
"""
def gen_rsa():
	private_key = rsa.generate_private_key(public_exponent=65537, key_size=2058)
	public_key = private_key.public_key()

	# gen private key
	private_pem = private_key.private_bytes(
		encoding=serialization.Encoding.PEM,
		format=serialization.PrivateFormat.PKCS8,
		encryption_algorithm=serialization.BestAvailableEncryption(pwd.encode())
	)

	# like eve from adam, we generate a public key from the private
	public_pem = public_key.public_bytes(
		encoding=serialization.Encoding.PEM,
		format=serialization.PublicFormat.SubjectPublicKeyInfo
	)
	
	private_pem = private_pem.decode()
	public_pem = public_pem.decode()
	
	# writing to our key storage files
	with open(prv_path, "w") as private_file:
		private_file.write(str(private_pem))
		
	with open(pub_path, "w") as public_file:
		public_file.write(str(public_pem))

"""
NAME	: load_public_rsa()
DESC	:
	Using our constant values defined at the top of this file, this functino opens
	the public rsa .key file, creates a public key object out of it, and returns it.
RTRN	: public key obj
PARM	//
"""
def load_public_rsa():
	with open(pub_path, "rb") as pub:
		# -- cryptography.hazmat.primitives.serialization.load_pem_private_key(data)
		# deserializes a public key from PEM data
		public_key = serialization.load_pem_public_key (
		# Passing the file's contents as the data field
		pub.read(),
		# Using "default backend"
		backend=default_backend()
		)
		
	return public_key

"""
NAME	: load_private_rsa()
DESC	:
	Identical as the aforementioned public rsa function, but for our private key.
RTRN	: private key obj
PARM	: //
"""
def load_private_rsa():
	with open(prv_path, "rb") as prv:
		private_key = serialization.load_pem_private_key (
			prv.read(),
			pwd.encode()
		)
		
	return private_key

"""
NAME	: decode_msg
DESC	:
	This function decodes a message given a key. It returns said decoded message.
	It doesn't catch exceptions, so always use it in a try block.
RTRN	: Binary message
PARM	: key, encoded message
"""
def decode_msg(key, msg):
	decoded_msg = key.decrypt (
		msg,
		padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
		algorithm=hashes.SHA256(),
		label=None )
	)
	
	return decoded_msg

"""
NAME	: encode_msg
DESC	:
	This function encodes a message, given a key and contents. It returns the
	encoded message. It doesn't catch exceptions, so be sure to use it in a try block.
RTRN	: encoded msg
PARM	: key, msg
"""
def encode_msg(key, msg):
	encoded_msg = key.encrypt (
		msg,
		padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
		algorithm=hashes.SHA256(),
		label=None )
	)
	
	return encoded_msg

"""
This is a little test harness function I wrote, just to ensure
that I can actually read the respctive keys from the files I'm
writing to, and encoding and decoding a message.
"""
def rsa_test_func():
	public_key = load_public_rsa()
	private_key = load_private_rsa()
	encoded_msg = public_key.encrypt (
		b'hello world',
		padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
		algorithm=hashes.SHA256(),
		label=None )
	)
	decoded_msg = private_key.decrypt (
		encoded_msg,
		padding.OAEP (mgf=padding.MGF1(algorithm=hashes.SHA256()),
		algorithm=hashes.SHA256(),
		label=None )
	)

	print(decoded_msg.decode())